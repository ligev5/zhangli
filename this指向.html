<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
</body>
<script>
//     在 js 中，this 的意思为“这个;当前”，是一个指针型变量，它动态指向当前函数的运行环境。
// this 跟函数相关，谁调用这个函数，this 就指向谁，所以 this 跟函数调用时候的环境而不是定义时候的环境相关。
// 如果没有调用者，就指向全局对象 window。

// 1. 构造函数
//    构造函数里的 this 指向实例化对象
// 2. 箭头函数
//    箭头函数里没有 this，用的 this 是上层所在环境的 this
// 3. 函数是对象的属性
//    this 指向这个对象
// 4. dom 节点调用一个事件 就指向这个 dom
// 5. 全局调用 就指向 widnow
// 6. 计时器里的 this 永远指向 window


    // 1.默认绑定

//     function foo() {
//   console.log(this)
//  }
//  foo()


//  function foo1() {
//    console.log(this)
//  }

//  function foo2() {
//    console.log(this)
//    foo1()
//  }

//  function foo3() {
//    console.log(this)
//    foo2()
//  }
//  全部指向window

//  2.隐式绑定
//  var obj = {
//   name: "why",
//   foo: foo
// }

// obj.foo() //obj对象

// var obj1 = {
//     name: "obj1",
//     foo: function() {
//       console.log(this)
//     }
//   }

//   var obj2 = {
//     name: "obj2",
//     bar: obj1.foo
//   }

//   obj2.bar()

    // 3.显示绑定
//     - 必须在调用的对象内部有一个对函数的引用（比如一个属性）；
// - 如果没有这样的引用，在进行调用时，会报找不到该函数的错误；
// - 正是通过这个引用，间接的将this绑定到了这个对象上

// 1.foo直接调用和call/apply调用的不同在于this绑定的不同
// foo直接调用指向的是全局对象(window)
// foo()

// var obj = {
//   name: "obj"
// }

// // call/apply是可以指定this的绑定对象
// foo.call(obj)
// foo.apply(obj)
// foo.apply("aaaa")


// // 2.call和apply区别，call和apply在执行函数时,是可以明确的绑定this, 这个绑定规则称之为显示绑定
// function sum(num1, num2, num3) {
//   console.log(num1 + num2 + num3, this)
// }

// sum.call("call", 20, 30, 40)
// sum.apply("apply", [20, 30, 40])

    // 5.箭头函数绑定
    // 他没有明确的指向，他里面的 this 其实是根据他的上级来定的，也就是他的 this 指向等于他的上级。
    // var func = () => {
    //       console.log(this);
    //     };
    //     var obj = {
    //       ber: func,
    //     };
    //     obj.ber(); //window

    //     var o = {
    //       a: 10,
    //       b: {
    //         a: 12,
    //         fn: function () {
    //           console.log(this.a);
    //         },
    //       },
    //     };
    //     o.b.fn(); //b



    //     在 js 中，this 的意思为“这个;当前”，是一个指针型变量，它动态指向当前函数的运行环境。
// this 跟函数相关，谁调用这个函数，this 就指向谁，所以 this 跟函数调用时候的环境而不是定义时候的环境相关。
// 如果没有调用者，就指向全局对象 window。

// 1. 构造函数
//    构造函数里的 this 指向实例化对象
// 2. 箭头函数
//    箭头函数里没有 this，用的 this 是上层所在环境的 this
// 3. 函数是对象的属性
//    this 指向这个对象
// 4. dom 节点调用一个事件 就指向这个 dom
// 5. 全局调用 就指向 widnow
// 6. 计时器里的 this 永远指向 window


    // 1.默认绑定

//     function foo() {
//   console.log(this)
//  }
//  foo()


//  function foo1() {
//    console.log(this)
//  }

//  function foo2() {
//    console.log(this)
//    foo1()
//  }

//  function foo3() {
//    console.log(this)
//    foo2()
//  }
//  全部指向window

//  2.隐式绑定
//  var obj = {
//   name: "why",
//   foo: foo
// }

// obj.foo() //obj对象

// var obj1 = {
//     name: "obj1",
//     foo: function() {
//       console.log(this)
//     }
//   }

//   var obj2 = {
//     name: "obj2",
//     bar: obj1.foo
//   }

//   obj2.bar()

    // 3.显示绑定
//     - 必须在调用的对象内部有一个对函数的引用（比如一个属性）；
// - 如果没有这样的引用，在进行调用时，会报找不到该函数的错误；
// - 正是通过这个引用，间接的将this绑定到了这个对象上

// 1.foo直接调用和call/apply调用的不同在于this绑定的不同
// foo直接调用指向的是全局对象(window)
// foo()

// var obj = {
//   name: "obj"
// }

// // call/apply是可以指定this的绑定对象
// foo.call(obj)
// foo.apply(obj)
// foo.apply("aaaa")


// // 2.call和apply区别，call和apply在执行函数时,是可以明确的绑定this, 这个绑定规则称之为显示绑定
// function sum(num1, num2, num3) {
//   console.log(num1 + num2 + num3, this)
// }

// sum.call("call", 20, 30, 40)
// sum.apply("apply", [20, 30, 40])

    // 5.箭头函数绑定
    // 他没有明确的指向，他里面的 this 其实是根据他的上级来定的，也就是他的 this 指向等于他的上级。
    // var func = () => {
    //       console.log(this);
    //     };
    //     var obj = {
    //       ber: func,
    //     };
    //     obj.ber(); //window

    //     var o = {
    //       a: 10,
    //       b: {
    //         a: 12,
    //         fn: function () {
    //           console.log(this.a);
    //         },
    //       },
    //     };
    //     o.b.fn(); //b




      //     在 js 中，this 的意思为“这个;当前”，是一个指针型变量，它动态指向当前函数的运行环境。
// this 跟函数相关，谁调用这个函数，this 就指向谁，所以 this 跟函数调用时候的环境而不是定义时候的环境相关。
// 如果没有调用者，就指向全局对象 window。

// 1. 构造函数
//    构造函数里的 this 指向实例化对象
// 2. 箭头函数
//    箭头函数里没有 this，用的 this 是上层所在环境的 this
// 3. 函数是对象的属性
//    this 指向这个对象
// 4. dom 节点调用一个事件 就指向这个 dom
// 5. 全局调用 就指向 widnow
// 6. 计时器里的 this 永远指向 window


    // 1.默认绑定

//     function foo() {
//   console.log(this)
//  }
//  foo()


//  function foo1() {
//    console.log(this)
//  }

//  function foo2() {
//    console.log(this)
//    foo1()
//  }

//  function foo3() {
//    console.log(this)
//    foo2()
//  }
//  全部指向window

//  2.隐式绑定
//  var obj = {
//   name: "why",
//   foo: foo
// }

// obj.foo() //obj对象

// var obj1 = {
//     name: "obj1",
//     foo: function() {
//       console.log(this)
//     }
//   }

//   var obj2 = {
//     name: "obj2",
//     bar: obj1.foo
//   }

//   obj2.bar()

    // 3.显示绑定
//     - 必须在调用的对象内部有一个对函数的引用（比如一个属性）；
// - 如果没有这样的引用，在进行调用时，会报找不到该函数的错误；
// - 正是通过这个引用，间接的将this绑定到了这个对象上

// 1.foo直接调用和call/apply调用的不同在于this绑定的不同
// foo直接调用指向的是全局对象(window)
// foo()

// var obj = {
//   name: "obj"
// }

// // call/apply是可以指定this的绑定对象
// foo.call(obj)
// foo.apply(obj)
// foo.apply("aaaa")


// // 2.call和apply区别，call和apply在执行函数时,是可以明确的绑定this, 这个绑定规则称之为显示绑定
// function sum(num1, num2, num3) {
//   console.log(num1 + num2 + num3, this)
// }

// sum.call("call", 20, 30, 40)
// sum.apply("apply", [20, 30, 40])

    // 5.箭头函数绑定
    // 他没有明确的指向，他里面的 this 其实是根据他的上级来定的，也就是他的 this 指向等于他的上级。
    // var func = () => {
    //       console.log(this);
    //     };
    //     var obj = {
    //       ber: func,
    //     };
    //     obj.ber(); //window

    //     var o = {
    //       a: 10,
    //       b: {
    //         a: 12,
    //         fn: function () {
    //           console.log(this.a);
    //         },
    //       },
    //     };
    //     o.b.fn(); //b
</script>
</html>